@top Program { Statement* }

@tokens {
  PreprocDirectiveName {
    "#" space* Identifier
  }

  Builtin {
    "gl_" @asciiLetter*
  }

  Const { "const" }

  PrimitiveNonVoidType {
    (Const space+)? (
      "bool" | "int" | "uint" | "float" | "double" |
      (("b"| "i" | "u" | "" | "d") "vec" ("2"|"3"|"4")) |
      ("mat" ("2"|"3"|"4") "x" ("2"|"3"|"4")) |
      ("mat" ("2"|"3"|"4"))
    )
  }

  PrimitiveType {
    "void" |
    PrimitiveNonVoidType space+
  }

  Identifier { (@asciiLetter | "_")+ ((@asciiLetter | "_") | @digit)* }
  
  LineComment { "//" ("\\\n" | ![\n])* }

  BlockComment { "/*" blockCommentRest }
  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }
  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  @precedence {Builtin, Identifier}

  @precedence { LineComment, BlockComment, "/" }
  
  String { '"' (!["\\] | "\\" _)* '"' }
  
  Boolean { "true" | "false" }

  Integer { @digit+ ("u"|"U")?}

  Float { (("." @digit+) | (@digit+ "." @digit*)) ("f" | "F")?}

  space { @whitespace+ }

  @precedence { PrimitiveType, PrimitiveNonVoidType, Identifier}
  @precedence { Float, Integer, Boolean, Identifier }

  @precedence {"<<", "<=", "<"}
  @precedence {">>", ">=", ">"}
}

@skip { space | LineComment | BlockComment }

ArithOp<expr> { expr }
BitOp<expr> { expr }
LogicOp<expr> { expr }
CompareOp<expr> { expr }

@precedence {
  subscript
  suffix @left
  prefix @left
  mult @left
  add @left
  bitShift @left
  greaterLess @left
  equal @left
  bitAnd @left
  bitXor @left
  bitOr @left
  logicAnd @left
  logicOr @left
  else @right
  ternary @right
}

kw<term> { @specialize[@name={term}]<Identifier, term> }

Statement {
  Block |
  ExpressionStatement |
  EmptyStatement |

  InVariableDeclaration |
  OutVariableDeclaration |
  UniformVariableDeclaration |

  VariableDeclaration |
  FunctionDeclaration |
  FunctionDefinition |

  StructDefinition |

  IfStatement |
  ForStatement |
  WhileStatement |
  DoWhileStatement |
  SwitchStatement |

  ContinueStatement |
  BreakStatement |
  ReturnStatement |

  PreprocDirectiveName |

  Reserved
}

Reserved {
  kw<"goto">
  | kw<"typedef">
  | kw<"enum">
  | kw<"class">
  | kw<"template">
  | kw<"using">
  | kw<"namespace">
  | kw<"extern">
  | kw<"this">
  | kw<"sizeof">
  | kw<"static">
  | kw<"volatile">
  | kw<"public"> /*??*/
  | kw<"long">
}

TypeIdentifier { PrimitiveType | Identifier }

EmptyStatement {
  ";"
}

ExpressionStatement {
  Expression ";"
}

ParenthesizedExpression {
  "(" Expression ")"
}

IfStatement {
  kw<"if"> ParenthesizedExpression Statement (!else kw<"else"> Statement)?
}

ForStatement {
  kw<"for"> "(" (VariableDeclaration | Expression ";" | ";") Expression? ";" Expression? ")" Statement
}

WhileStatement {
  kw<"while"> ParenthesizedExpression Statement
}

DoWhileStatement {
  kw<"do"> Statement kw<"while"> ParenthesizedExpression ";"
}

SwitchStatement {
  kw<"switch"> ParenthesizedExpression "{" CaseStatement* "}"
}

CaseStatement {
  (kw<"case"> Expression)| kw<"default"> ":" Statement
}

ContinueStatement {
  kw<"continue"> ";"
}

BreakStatement{
  kw<"break"> ";"
}

ReturnStatement{
  kw<"return"> Expression? ";"
}

InVariableDeclaration {
  kw<"in"> PrimitiveNonVoidType Identifier ("=" Expression)? ";"
}

OutVariableDeclaration {
  kw<"out"> PrimitiveNonVoidType Identifier ("=" Expression)? ";"
}

UniformVariableDeclaration {
  kw<"uniform"> PrimitiveNonVoidType Identifier ("=" Expression)? ";"
}

VariableDeclaration {
  TypeIdentifier Identifier ("=" Expression)? ";"
}

FunctionDeclaration {
  FunctionHeader ";"
}

FunctionDefinition {
  FunctionHeader Block
}

ArgumentList{
  "(" (TypeIdentifier Identifier ("," TypeIdentifier Identifier)*)? ")"
}

FunctionHeader {
  TypeIdentifier Identifier ArgumentList
}

StructDefinition {
  kw<"struct"> "{" VariableDeclaration* "}" ";"
}

Block {
  "{" Statement* "}"
}

Expression {
  Builtin |
  Identifier|
  String |
  Integer |
  Float |
  Boolean |

  ParenthesizedExpression |

  BinaryExpression{
    Expression !add ArithOp<"+" | "-"> Expression |
    Expression !mult ArithOp<( "*"  | ("/" | "%"))> Expression |
    Expression !logicAnd LogicOp { "&&" } Expression |
    Expression !logicOr LogicOp { "||" } Expression |
    Expression !bitOr BitOp<"|"> Expression |
    Expression !bitXor BitOp<"^"> Expression |
    Expression !bitAnd BitOp { "&" } Expression |
    Expression !equal CompareOp<"==" | "!="> Expression |
    Expression !greaterLess (CompareOp<"<=" | ">=" > | @extend[@name=CompareOp]<"<"> | @extend[@name=CompareOp]<">">) Expression | /*copy-paste from example now, understand later*/
    Expression !bitShift BitOp<"<<" | ">>"> Expression
  } |

  UnaryExpression{
    (LogicOp<"!"> | ArithOp<"+" | "-"> | BitOp<"~">) !suffix Expression|

    ("--" | "++") !suffix Expression | Expression !prefix ("--" | "++")
  } |

  AssignmentExpression{
    Identifier "=" Expression
  } |

  TernaryExpression{
    Expression !ternary "?" Expression ":" Expression
  } |

  FieldExpression {
    Expression !subscript "." Identifier
  } |

  CallExpression {
    Identifier ArgumentList
  }
}

@detectDelim
