@top Program { Statement* }

@tokens {
  PreprocDirectiveName {
    "#" space* Identifier
  }

  Builtin {
    "gl_" (@asciiLetter | "_" | @digit)*
  }

  Identifier { (@asciiLetter | "_")+ (@asciiLetter | "_" | @digit)* }
  
  LineComment { "//" ("\\\n" | ![\n])* }

  BlockComment { "/*" blockCommentRest }
  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }
  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  @precedence {Builtin, Identifier}

  @precedence { LineComment, BlockComment, "/" }
  
  String { '"' (!["\\] | "\\" _)* '"' }
  
  Integer { @digit+ ("u"|"U")?}

  Float { (("." @digit+) | (@digit+ "." @digit*)) ("f" | "F")?}

  space { @whitespace+ }

  "="[@name=Equals]

  "(" ")" "[" "]" "{" "}"

  ","

  @precedence { Float, Integer, Identifier }

  @precedence {"<<", "<=", "<"}
  @precedence {">>", ">=", ">"}
}

@skip { space | LineComment | BlockComment }

ArithOp<expr> { expr }
BitOp<expr> { expr }
LogicOp<expr> { expr }
CompareOp<expr> { expr }

@precedence {
  subscript
  suffix @left
  prefix @left
  mult @left
  add @left
  bitShift @left
  greaterLess @left
  equal @left
  bitAnd @left
  bitXor @left
  bitOr @left
  logicAnd @left
  logicOr @left
  else @right
  ternary @right
}

kw<term> { @specialize[@name={term}]<Identifier, term> }

primitiveType {
  @specialize[@name="PrimitiveType"]<Identifier,
    "int"   | "double" | "float"  | "void" | "bool" | "uint" |
    "bvec2" | "bvec3"  | "bvec4"  |
    "ivec2" | "ivec3"  | "ivec4"  |
    "uvec2" | "uvec3"  | "uvec4"  |
    "vec2"  | "vec3"   |  "vec4"  |
    "dvec2" | "dvec3"  | "dvec4"  |
    "mat2"  | "mat2x2" | "mat2x3" | "mat2x4" |
    "mat3"  | "mat3x2" | "mat3x3" | "mat3x4" |
    "mat4"  | "mat4x2" | "mat4x3" | "mat4x4">
}

Const {
  @specialize[@name="PrimitiveType"]<Identifier, "const">
}

Statement {
  Block |
  ExpressionStatement |
  EmptyStatement |

  InVariableDeclaration |
  OutVariableDeclaration |
  UniformVariableDeclaration |

  VariableDeclaration |
  FunctionDeclaration |
  FunctionDefinition |

  StructDefinition |

  IfStatement |
  ForStatement |
  WhileStatement |
  DoWhileStatement |
  SwitchStatement |

  ContinueStatement |
  BreakStatement |
  ReturnStatement |

  PreprocDirectiveName |

  Reserved
}

Reserved {
  kw<"goto">
  | kw<"typedef">
  | kw<"enum">
  | kw<"class">
  | kw<"template">
  | kw<"using">
  | kw<"namespace">
  | kw<"extern">
  | kw<"this">
  | kw<"sizeof">
  | kw<"static">
  | kw<"volatile">
  | kw<"public"> /*??*/
  | kw<"long">
}

TypeIdentifier { Const? (primitiveType | Identifier) }

EmptyStatement {
  ";"
}

ExpressionStatement {
  Expression ";"
}

ParenthesizedExpression {
  "(" Expression ")"
}

IfStatement {
  kw<"if"> ParenthesizedExpression Statement (!else kw<"else"> Statement)?
}

ForStatement {
  kw<"for"> "(" (VariableDeclaration | Expression ";" | ";") Expression? ";" Expression? ")" Statement
}

WhileStatement {
  kw<"while"> ParenthesizedExpression Statement
}

DoWhileStatement {
  kw<"do"> Statement kw<"while"> ParenthesizedExpression ";"
}

SwitchStatement {
  kw<"switch"> ParenthesizedExpression "{" CaseStatement* "}"
}

CaseStatement {
  (kw<"case"> Expression)| kw<"default"> ":" Statement
}

ContinueStatement {
  kw<"continue"> ";"
}

BreakStatement{
  kw<"break"> ";"
}

ReturnStatement{
  kw<"return"> Expression? ";"
}

InVariableDeclaration {
  kw<"in"> primitiveType Identifier ("=" Expression)? ";"
}

OutVariableDeclaration {
  kw<"out"> primitiveType Identifier ("=" Expression)? ";"
}

UniformVariableDeclaration {
  kw<"uniform"> primitiveType Identifier ("=" Expression)? ";"
}

VariableDeclaration {
  TypeIdentifier Identifier ("=" Expression)? ";"
}

FunctionDeclaration {
  FunctionHeader ";"
}

FunctionDefinition {
  FunctionHeader Block
}

TypedArgumentList {
  "(" (TypeIdentifier Identifier ("," TypeIdentifier Identifier)*)? ")"
}

FunctionHeader {
  TypeIdentifier Identifier TypedArgumentList
}

StructDefinition {
  kw<"struct"> "{" VariableDeclaration* "}" ";"
}

Block {
  "{" Statement* "}"
}

Expression {
  Builtin |
  Identifier|
  String |
  Integer |
  Float |
  @specialize[@name="Boolean"]<Identifier, "true" | "false"> |

  ParenthesizedExpression |

  BinaryExpression{
    Expression !add ArithOp<"+" | "-"> Expression |
    Expression !mult ArithOp<( "*"  | ("/" | "%"))> Expression |
    Expression !logicAnd LogicOp { "&&" } Expression |
    Expression !logicOr LogicOp { "||" } Expression |
    Expression !bitOr BitOp<"|"> Expression |
    Expression !bitXor BitOp<"^"> Expression |
    Expression !bitAnd BitOp { "&" } Expression |
    Expression !equal CompareOp<"==" | "!="> Expression |
    Expression !greaterLess (CompareOp<"<=" | ">=" > | @extend[@name=CompareOp]<"<"> | @extend[@name=CompareOp]<">">) Expression | /*copy-paste from example now, understand later*/
    Expression !bitShift BitOp<"<<" | ">>"> Expression
  } |

  UnaryExpression{
    (LogicOp<"!"> | ArithOp<"+" | "-"> | BitOp<"~">) !suffix Expression|

    ("--" | "++") !suffix Expression | Expression !prefix ("--" | "++")
  } |

  AssignmentExpression{
    Identifier "=" Expression
  } |

  TernaryExpression{
    Expression !ternary "?" Expression ":" Expression
  } |

  FieldExpression {
    Expression !subscript "." Identifier
  } |

  CallExpression {
    Identifier "(" (Expression ("," Expression)* )? ")"
  } |

  CastOrConstructExpression {
    primitiveType "(" (Expression ("," Expression)* )? ")"
  }
}

@detectDelim